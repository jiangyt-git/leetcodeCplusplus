1. 贪心算法基本思想：考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始
2. 要求：
    要有最优子结构性质
    贪心选择性质，每一次的选择结果是一次局部最优解。
3. 贪心算法自顶向下的进行, a.在当前状态下先选择局部最优选择，b.然后再去解决这个选择后产生的子问题，c.最终所有的局部最优解合成原来的一个最优解
4. 核心是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。
5. 例子：
    1)冒泡排序，每次从剩下的中取出一个最大值。
    2)背包问题（物品可分割），很多宝物，a.每次取 价值/重量 最大的宝物, b.取剩下所有中的性价比最高宝物，c.所有宝物加在一起就是最优解。但是不可分割时，最后可能会有空余位置，导致不是最优解而是最优解的近似解。
    3)0-1背包问题(物体不可分割)，已经不具备贪心选择性质。
    4)会议安排问题(区间排序问题),会议为一个区间[b,e)，尽可能在有限的时间内安排更多的会议。 贪心策略是每次选择结束时间最早且与已安排会议相融的会议。
        a. 初始化：
            构建数据结构，包含会议编号(如果输出不需要具体的哪几个会议就不需要编号)、开始时间、结束时间。
            排序： 按照结束时间从小到大，开始时间从大到小排序。
        b. 贪心选择：选取最早一个结束的时间，记录最后结束时间为last
        c. 子问题：一次从剩下的会议中选择， 
            对会议i,如果开始时间大等于last的结束时间，选择会议i,更新last为i的结束时间, exit。
            否则，舍弃会议i，继续下一个会议选择。
    5) dijkstra 单源最短路径（一个起始出发点） 
        1. 初始化：一个二位数组map[u][i] 记录源点到所有点的最短路径，可以直达的记录直达距离，否则初始化为无穷大。 一个集合S初始只含有源点，一个集合初始只含有其余所有点
           一个一维数组dist[i]，记录u到i的最短路径，因为map[u][i]是中间结果，dist[i]是最终结果，初始化时。
           一个一位数组p[i]， 记录最短路径上i节点的前驱，初始化时与源点相连的为u，否则为-1.
           一个一维数组flag[], 记录S集合,true表示节点已经加入S,初始使只有flag[u]为true.
        2. 贪心选择
           在剩下所有的点中选取一个点t，使得dist[t] = min,（在dist数组中选取最小值即可，当然这个点必须使没有加入最后集合的点） 将选择的点加入最终集合S，剩下的点的集合也更新。
           如果所有的点都加入进去了，就结束。否则，根据选择，更新其余点，
           贪心选择已经做好，选择了点t，根据点t，判断所有与t相邻的点i，从源点到t比当前路径map[u][i]更短: dsit[t] + map[t][i] < map[u][i], 记录前驱p[i]=t 
        3. 子问题，
            重新去步骤2
        结果：得到源点到所有点的最短路径，然后根据p[]逆向得到所有经过的路径。
        4. 代码（没有test过）
           最终dist数组是源点到所有点的最短路径值，然后根据p[]逆向得到所有经过的路径。
           看代码Dijkstra.cc 
