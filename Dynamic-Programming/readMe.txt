1. 当分治法的子问题重合度非常高的时候，就可以使用动态规划。
2. 使用动态规划的问题具有的性质：
    a) 最优子结构: 问题的最优解包含了 子问题的最优解.  《--必须要有此性质--》
    b) 子问题重叠
3. 解决步骤
    a) 分析最优解的结构特征
    b) 建立最优值的递归式
    c) 自底向上计算最优值，并记录
    d) 构造最优解
4. 例子：
    1）Fibonacci序列
        f(1) = 1, 有一对兔子 1
        f(2) = 1, 一对兔子成熟 1
        f(n) = f(n-1) + f(n-2) 成熟兔子生产 1+1
    2）最长公共子序列    
        a) 分析最优解的结构特征
            如果Xm 是Yn的最长公共子序列是Zk,可以分为3种情况：   Xm = {x1，x2，…… xm}
            1)) x(m) = y(n) = z(k)  即序列最后一个值相等， 那么  z（k-1） 是 x(m-1) 和y(n-1) 的最长公共子序列
            2)) x(m) != y(n), x(m) != z(k) , 那么可以把x(m)去掉， z(k) 是 x(m-1) 和 y(n) 的最长公共子序列
            3)) x(m) != y(n), y(n) != z(k) , 那么可以把y(n)去掉， z(k) 是 x(m) 和 y(n-1) 的最长公共子序列
        b） 建立最优值递归式
            用c[i][j] 表示 Xi、Yj的最长公共子序列
            1)) x(m) = y(n)  那么 c[i][j] = c[i-1][j-1] + 1;
            2)) x(m) != y(n), 
                    x(m) != z(k) , c[i][j] = c[i][j-1] + 1
                    y(n) != z(k) , c[i][j] = c[i-1][j] + 1
                    那么取两者最大。
            总结：  
                c[0][0] = 0,                                    i=0 或者 j=0
                c[i][j] = c[i-1][j-1] + 1,                      i、j >0 且  xi == yi
                c[i][j] = max{c[i][j-1] + 1, c[i-1][j] + 1},    i、j >0 且  xi != yi
        c) 自底向上计算最优值，并记录最优值和最优策略
            b[i][j]辅助记录是从3种可能的哪种来源来的1、2、3分别表示c[i-1][j-1]、 c[i][j-1]、 c[i-1][j]，以便回溯真正的字符串。    
            i = 1时, {x1} 和 {y1, y2, y3, …… yn} 中的字符一一比较，按递归式求解并记录最长公共子序列的长度
                x1和y1比较，相等 c[1][1] = c[0][0] + 1, b[1][1] == 1 ;
                           不等 c[1][1] = 0, 如果c[1][0]>= c[0][1], b[1][1] == 2, 因为来源于c[1][0],否则 b[1][1] == 3;
                x1和y2比较，相等 c[1][2] = c[0][1]+1 = 1,  b[1][1] == 1 ;
                           不等 c[1][2] = max{c[0][2], c[1][1]}, 如果c[0][2]>= c[1][1], b[1][2] == 3, 因为来源于c[0][2]，否则b[1][2] == 2;
            i = 2时, {x2} 和 {y1, y2, y3, …… yn} 中的字符一一比较，按递归式求解并记录最长公共子序列的长度
            i = m时, {xm} 和 {y1, y2, y3, …… yn} 中的字符一一比较，按递归式求解并记录最长公共子序列的长度
            就是填充两个二维数组，c[][]要不取左上角+1，要不去左和上中的max;
        d） 构造最优解
            如得到c[m][n] = 5,反向递推：
            c[i][j]的来源有3个，c[i-1][j-1]、 c[i][j-1]、 c[i-1][j] ，可以使用 1、2、3 表示是从哪个得到的，并记录下来，
            比如记录辅助数组b[i][j] = 2，表示最短路径是从 c[i][j-1]来的，b[i][j] = 1 ，表示最短路径是从 c[i-1][j-1]来的,那么结果总就有x(i-1) == y(i-1)
            直到i=0或者j=0为止
            输出函数print(){
                是遍历b[][]数组，
                    b[i][j] = 1 , 说明 x[i-1] = y[j-1], 递归求解 b[i-1][j-1]，输出 x[i-1],   先递归再输出才是正序，否则是倒序
                    b[i][j] = 2 , 递归求解 b[i][j-1],
                    b[i][j] = 3 ,  递归求解 b[i-1][j],
                当i = 0 || j = 0 ，递归结束。        
            }
            就是从b[][]数组的右下角开始，往 左|上|左上 一直走，直到走到了最左列或者最上行。
        e） 代码
            const int N = 1000;
            int b[N][N];
            int c[N][N];
            // 求最长子序列的矩阵
            void LSCL(char[] s1, char[] s2, int len1, int len2) {
                for (int i = 1; i <= len1; i++) {
                    for (int j = 1; j <= len2; j++) {
                        if (s1[i-1] == s2[j-1]) {
                            //相等
                            c[i][j] = c[i-1][j-1] + 1;
                            b[i][j] = 1;
                        } else if (c[i][j-1] >= c[i-1][j]) {
                            c[i][j] = c[i][j-1];
                            b[i][j] = 2;
                        } else {
                            c[i][j] = c[i-1][j];
                            b[i][j] = 3;
                        }
                    }
                }
            }
            // 计算完成之后，输出最长子序列的矩阵
            void print(int m, int n) {
                if (m == 0 || n == 0) {
                    // 遍历到了第一列或者第一行
                    return ;
                }
                if (b[m][n] == 1) {
                    //递归b[m-1][n-1]
                    print(b[m-1][n-1]);
                    std::cout<<s[m-1];

                } else if(b[m][n] == 2) {
                    //递归b[m][n-1]
                    print(b[m][n-1]);
                } else {
                    //递归b[m-1][n]
                    print(b[m-1][n]);
                }
             }
    3）两个字符串的编辑距离，即将一个字符串变换为另一个字符串所需要的最小编辑操作（插入一个字符、删除一个字符、替换某个字符）
        a) 分析最优解的结构特征
            假设c[i][j]是{x1…… xi} 和 {y1…… yj}的编辑距离的最优解，那么可以分为下面4种情况
            1）需要删除xi
                x(i-1) 与 yi 已经对齐了，所以需要删除xi，代价加一
                c[i][j] = c[i-1][j] + 1
            2) 需要插入yj
                xi 与 y(i-1) 已经对齐了，所以需要删除yi，代价加一
                c[i][j] = c[i][j-1]
            3) 需要替换 或者 不用替换
                x(i-1) 与 y(i-1) 已经对齐了
                a) xi == yj 则 c[i][j] = c[i-1][j-1]， 不需要编辑了
                b) xi != yj 则 c[i][j] = c[i-1][j-1] +1， 需要替换，代价加一
        b) 建立最有递归值
            取上述三者的最小值即可
            c[i][j] = min {c[i-1][j] + 1,    c[i][j-1],    c[i-1][j-1]+ diff   } 
        c) 自底向上计算最优值，并记录最优值和最优策略
            i = 1时， x0分别于y（j-1） j从1到j字符串进行一一比较
                相等? c[i][j-1] = 0, 因为不存在 c[-1][-1] 
                不相等， c[0][1] = min {c[i-1][j]+1,  c[i][j-1]+1,  c[i-1][j-1]+ diff}
            i = 2时, x1分别于y（j-1） j从1到j字符串进行一一比较
            i = i时，x2分别于y（j-1） j从1到j字符串进行一一比较
        d) 构造最优解
            解释题目为从字符串x编辑后变为y
            从表格倒推，没有使用辅助数组，就采用判断的方式推断，从c[i][j]开始倒推
            判断x[i-1] 和y[j-1]相等吗，
                相等，则不需操作，然后回溯左、上、左上中最小的。
                不相等，则判断是左、上、左上中最小的哪个得到的，
                    左上， 表示替换，输出x[i-1] 替换为 y[j-1]
                    上，表示插入得到，插入 y[j-1]
                    左，表示删除得到 ,删除x[i-1]
            左、上、左上3个值相等时，可以自己一个顺序，比如左上、
                    
        e) 代码
            初始化时，第一列为0，1，2，3，4，5 第一列为0，1，2，3，4，5，6 …… 
            int editDistance (char * str1, char * str2) {
                int len1 = strlen(str1);
                int len2 = strlen(str2);
                int[][] dist = new int[len1][len2];

                //第二个字符串为0时
                int i = 0;
                for (i = 0; i <= len1; i++) {
                    c[i0][0] = i;
                }
                //第一个字符串为0时
                int j = 0;
                for (j = 0; j <= len2; j++) {
                    c[o][j] = j;
                }
                for (i = 1; i <= len1; i++) {
                    for (j = 1; j <= len2; j++) {
                        // 当前字符串相等
                        int diff = 0;
                        if (str1[i] != str2[i]) {
                            diff = 1;
                        }
                        // min函数自主实现
                        c[i][j] = min (min(c[i-1][j]+1, c[i][j-1]+1), c[i-1][j-1] + diff);
                    }
                }
                return c[len1][len2];
            }  
    4）        
            
