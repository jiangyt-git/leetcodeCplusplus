1. 当分治法的子问题重合度非常高的时候，就可以使用动态规划。
2. 使用动态规划的问题具有的性质：
    a) 最优子结构: 问题的最优解包含了 子问题的最优解.  《--必须要有此性质--》
    b) 子问题重叠
3. 解决步骤
    a) 分析最优解的结构特征
    b) 建立最优值的递归式
    c) 自底向上计算最优值，并记录
    d) 构造最优解
4. 例子：
    1）Fibonacci序列
        f(1) = 1, 有一对兔子 1
        f(2) = 1, 一对兔子成熟 1
        f(n) = f(n-1) + f(n-2) 成熟兔子生产 1+1
    2）最长公共子序列    
        a) 分析最优解的结构特征
            如果Xm 是Yn的最长公共子序列是Zk,可以分为3种情况：   Xm = {x1，x2，…… xm}
            1)) x(m) = y(n) = z(k)  即序列最后一个值相等， 那么  z（k-1） 是 x(m-1) 和y(n-1) 的最长公共子序列
            2)) x(m) != y(n), x(m) != z(k) , 那么可以把x(m)去掉， z(k) 是 x(m-1) 和 y(n) 的最长公共子序列
            3)) x(m) != y(n), y(n) != z(k) , 那么可以把y(n)去掉， z(k) 是 x(m) 和 y(n-1) 的最长公共子序列
        b） 建立最优值递归式
            用c[i][j] 表示 Xi、Yj的最长公共子序列
            1)) x(m) = y(n) = z(k)  那么 c[i][j] = c[i-1][j-1] + 1;
            2)) x(m) != y(n), 
                    x(m) != z(k) , c[i][j] = c[i][j-1] + 1
                    y(n) != z(k) , c[i][j] = c[i-1][j] + 1
                    那么取两者最大。
            总结：  
                c[0][0] = 0,                                    i=0 或者 j=0
                c[i][j] = c[i-1][j-1] + 1,                      i、j >0 且  xi == yi
                c[i][j] = max{c[i][j-1] + 1, c[i-1][j] + 1},    i、j >0 且  xi != yi
        c) 自底向上计算最优只，并记录最优值和最优策略
            b[i][j]辅助记录是从3种可能的哪种来源来的1、2、3分别表示c[i-1][j-1]、 c[i][j-1]、 c[i-1][j]，以便回溯真正的字符串。    
            i = 1时, {x1} 和 {y1, y2, y3, …… yn} 中的字符一一比较，按递归式求解并记录最长公共子序列的长度
                x1和y1比较，相等 c[1][1] = c[0][0] + 1, b[1][1] == 1 ;
                           不等 c[1][1] = 0, 如果c[1][0]>= c[0][1], b[1][1] == 2, 因为来源于c[1][0],否则 b[1][1] == 3;
                x1和y2比较，相等 c[1][2] = c[0][1]+1 = 1,  b[1][1] == 1 ;
                           不等 c[1][2] = max{c[0][2], c[1][1]}, 如果c[0][2]>= c[1][1], b[1][2] == 3, 因为来源于c[0][2]，否则b[1][2] == 2;
            i = 2时, {x2} 和 {y1, y2, y3, …… yn} 中的字符一一比较，按递归式求解并记录最长公共子序列的长度
            i = m时, {xm} 和 {y1, y2, y3, …… yn} 中的字符一一比较，按递归式求解并记录最长公共子序列的长度
        d） 构造最优解
            如得到c[m][n] = 5,反向递推：
            c[i][j]的来源有3个，c[i-1][j-1]、 c[i][j-1]、 c[i-1][j] ，可以使用 1、2、3 表示是从哪个得到的，并记录下来，
            比如记录辅助数组b[i][j] = 2，表示最短路径是从 c[i][j-1]来的，b[i][j] = 1 ，表示最短路径是从 c[i-1][j-1]来的,那么结果总就有x(i-1) == y(i-1)
            直到i=0或者j=0为止
            输出函数print(){
                是遍历b[][]数组，
                    b[i][j] = 1 , 说明 x[i-1] = y[j-1], 递归求解 b[i-1][j-1]，输出 x[i-1],   先递归再输出才是正序，否则是倒序
                    b[i][j] = 2 , 递归求解 b[i][j-1],
                    b[i][j] = 3 ,  递归求解 b[i-1][j],
                当i = 0 || j = 0 ，递归结束。        
            }
        d）     
